<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>PDS Model Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #eee;
            font-family: sans-serif;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 300px;
            background: #222;
            border-right: 1px solid #444;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #sidebar h2 {
            padding: 10px;
            margin: 0;
            background: #333;
            font-size: 1.1em;
        }

        .category {
            margin-bottom: 10px;
        }

        .category-title {
            padding: 5px 10px;
            background: #2a2a2a;
            border-bottom: 1px solid #444;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            user-select: none;
        }

        .category-title:hover {
            background: #333;
        }

        .asset-list {
            display: none;
        }

        .category.open .asset-list {
            display: block;
        }

        .asset-item {
            padding: 3px 10px 3px 20px;
            cursor: pointer;
            font-size: 0.85em;
            color: #aaa;
        }

        .asset-item:hover {
            background: #333;
            color: #fff;
        }

        .asset-item.active {
            background: #0066cc;
            color: #fff;
        }

        #viewer {
            flex-grow: 1;
            position: relative;
        }

        #info-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8em;
            pointer-events: none;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <div id="sidebar">
        <h2>Assets</h2>
        <div id="asset-list-container">Loading...</div>
    </div>
    <div id="viewer">
        <div id="info-panel">
            Select a model
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let currentModel = null;

        async function init() {
            // Setup Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x888888);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerWidth - 300), 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            const viewerContainer = document.getElementById('viewer');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            viewerContainer.appendChild(renderer.domElement);

            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
            } else {
                console.warn("OrbitControls not loaded correctly");
            }

            window.addEventListener('resize', onWindowResize);

            // Load list
            await loadAssetList();

            animate();
        }

        async function loadAssetList() {
            try {
                const response = await fetch('/api/assets');
                const assets = await response.json();
                renderAssetList(assets);
            } catch (e) {
                console.error("Failed to load assets:", e);
                document.getElementById('asset-list-container').innerText = "Error loading assets.";
            }
        }

        function renderAssetList(categories) {
            const container = document.getElementById('asset-list-container');
            container.innerHTML = '';

            for (const [category, items] of Object.entries(categories)) {
                if (items.length === 0) continue;

                const catDiv = document.createElement('div');
                catDiv.className = 'category';

                const titleDiv = document.createElement('div');
                titleDiv.className = 'category-title';
                titleDiv.innerText = `${category} (${items.length})`;
                titleDiv.onclick = () => catDiv.classList.toggle('open');

                const listDiv = document.createElement('div');
                listDiv.className = 'asset-list';

                items.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'asset-item';
                    itemDiv.innerText = item.name;
                    itemDiv.onclick = () => loadModel(item.name);
                    listDiv.appendChild(itemDiv);
                });

                catDiv.appendChild(titleDiv);
                catDiv.appendChild(listDiv);
                container.appendChild(catDiv);
            }
        }

        async function loadModel(name) {
            console.log("Loading model:", name);
            document.getElementById('info-panel').innerText = `Loading ${name}...`;

            try {
                const response = await fetch(`/api/model/${name}`);
                if (!response.ok) throw new Error("Model not found");
                const modelData = await response.json();

                // Clear old model
                if (currentModel) {
                    scene.remove(currentModel);
                    // Dispose logic (optional for this demo but good practice)
                    currentModel.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                            else child.material.dispose();
                        }
                    });
                }

                currentModel = new THREE.Group();

                let totalVertices = 0;
                let totalFaces = 0;

                for (const [key, groupData] of Object.entries(modelData.groups)) {
                    const geometry = new THREE.BufferGeometry();

                    const positions = new Float32Array(groupData.positions);
                    const uvs = new Float32Array(groupData.uvs);

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                    // Material
                    let material;
                    const texIndex = groupData.texture_index;

                    if (texIndex !== undefined && texIndex >= 0 && modelData.has_textures) {
                        const texture = new THREE.TextureLoader().load(`/api/texture/${name}/${texIndex}`);
                        texture.magFilter = THREE.NearestFilter;
                        texture.minFilter = THREE.NearestFilter;

                        material = new THREE.MeshBasicMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            transparent: true,
                            alphaTest: 0.5
                        });
                    } else {
                        const hash = key.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
                        const color = new THREE.Color().setHSL((hash % 100) / 100, 0.7, 0.5);
                        material = new THREE.MeshLambertMaterial({
                            color: color,
                            side: THREE.DoubleSide
                        });
                    }

                    const mesh = new THREE.Mesh(geometry, material);
                    currentModel.add(mesh);

                    totalVertices += positions.length / 3;
                    totalFaces += positions.length / 9;
                }

                scene.add(currentModel);

                document.getElementById('info-panel').innerText = `Model: ${name}\nGroups: ${Object.keys(modelData.groups).length}\nVertices: ${totalVertices}\nFaces: ${totalFaces.toFixed(0)}`;
            } catch (e) {
                console.error(e);
                document.getElementById('info-panel').innerText = `Error loading ${name}: ${e.message}`;
            }
        }

        function onWindowResize() {
            const viewerContainer = document.getElementById('viewer');
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>