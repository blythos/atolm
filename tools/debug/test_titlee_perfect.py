import struct
import zlib
import sys, os

def get_pixel_8bpp(tile_data, x, y):
    if not tile_data: return 0
    cell_idx = (y // 8) * 2 + (x // 8)
    byte_offset = cell_idx * 64 + (y % 8) * 8 + (x % 8)
    if byte_offset >= len(tile_data): return 0
    return tile_data[byte_offset]

def get_pixel_4bpp(tile_data, x, y):
    if not tile_data: return 0
    cell_idx = (y // 8) * 2 + (x // 8)
    byte_offset = cell_idx * 32 + (y % 8) * 4 + (x // 2)
    if byte_offset >= len(tile_data): return 0
    b = tile_data[byte_offset]
    return (b >> 4) if (x % 2 == 0) else (b & 0xF)

def decode_entry_10bit(val):
    return {
        'character_number': val & 0x3FF,
        'palette_number': (val >> 10) & 0xF,
        'h_flip': bool(val & 0x4000),
        'v_flip': bool(val & 0x8000),
    }

def decode_entry_12bit(val):
    return {
        'character_number': val & 0xFFF,
        'palette_number': (val >> 12) & 0x7,
        'h_flip': False,
        'v_flip': False,  # usually not present in 12-bit mode
    }

def build_palette(palette_data):
    # Parses the massive 4096-byte block into 2048 RGBA colors
    rgba_palette = []
    num_colors = len(palette_data) // 2
    for i in range(num_colors):
        val = struct.unpack_from('>H', palette_data, i * 2)[0]
        r = (val & 0x1F) << 3
        g = ((val >> 5) & 0x1F) << 3
        b = ((val >> 10) & 0x1F) << 3
        a = 255 # Disable transparency for testing so we don't accidentally hide pixels
        rgba_palette.append((r, g, b, a))
    return rgba_palette

def render(pnb_path, scb_path, palette_data, out_path, bpp=8, is_12bit=False):
    with open(pnb_path, 'rb') as f:
        pnb_data = f.read()
    with open(scb_path, 'rb') as f:
        scb_data = f.read()

    entries = struct.unpack(f'>{len(pnb_data)//2}H', pnb_data)
    
    # Simple bounds just for verification
    num_planes = max(1, len(entries) // 1024)
    planes_h = 2 if num_planes in (2, 4) else 1
    planes_v = num_planes // planes_h
    width_tiles = planes_h * 32
    height_tiles = planes_v * 32

    rgba_palette = build_palette(palette_data)
    rgba_rows = [bytearray() for _ in range(height_tiles * 16)]

    vram_base = 0 # Assume 0 for TITLEE, might be different others

    for plane_idx in range(num_planes):
        px_offset = (plane_idx % planes_h) * 32
        py_offset = (plane_idx // planes_h) * 32
        
        plane_entries = entries[plane_idx * 1024: (plane_idx + 1) * 1024]
        
        for ty in range(32):
            for tx in range(32):
                val = plane_entries[ty * 32 + tx]
                
                d = decode_entry_12bit(val) if is_12bit else decode_entry_10bit(val)
                char_idx = d['character_number']
                pal_num = d['palette_number']
                
                tile_offset = char_idx * 0x80  # 128 bytes (char mult)
                if tile_offset + 256 <= len(scb_data):
                    tile_data = scb_data[tile_offset:tile_offset+256]
                else:
                    tile_data = None
                    
                for py in range(16):
                    target_y = (py_offset + ty) * 16 + py
                    for px in range(16):
                        if bpp == 8:
                            px_val = get_pixel_8bpp(tile_data, px, py)
                            color_idx = px_val % len(rgba_palette)
                        else:
                            px_val = get_pixel_4bpp(tile_data, px, py)
                            color_idx = (pal_num * 16 + px_val) % len(rgba_palette)
                            
                        r, g, b, a = rgba_palette[color_idx]
                        rgba_rows[target_y].extend([r, g, b, a])

    def _chunk(chunk_type, data):
        c = chunk_type + data
        crc = struct.pack('>I', zlib.crc32(c) & 0xFFFFFFFF)
        return struct.pack('>I', len(data)) + c + crc
    ihdr = struct.pack('>IIBBBBB', width_tiles*16, height_tiles*16, 8, 6, 0, 0, 0)
    raw = b''
    for row in rgba_rows:
        raw += b'\x00' + row
    compressed = zlib.compress(raw)
    with open(out_path, 'wb') as f:
        f.write(b'\x89PNG\r\n\x1a\n')
        f.write(_chunk(b'IHDR', ihdr))
        f.write(_chunk(b'IDAT', compressed))
        f.write(_chunk(b'IEND', b''))
    print(f'Saved {out_path}')


# 1. Test TITLEE with hardcoded palette
pal = bytes([
    0xFF, 0xFF, 0x7F, 0xFF, 0x7B, 0xFF, 0x77, 0xFF, 0x73, 0xFF, 0x6F, 0xFF, 0x73, 0xDF, 0x6B, 0xFF,
    0x6F, 0xFE, 0x6B, 0xDF, 0x67, 0xBF, 0x6B, 0xBE, 0x77, 0x5E, 0x63, 0xDE, 0x67, 0xBE, 0x57, 0xFF,
    0x5F, 0xFE, 0x5B, 0xDF, 0x57, 0xBF, 0x5F, 0x9F, 0x67, 0x7E, 0x6B, 0x7E, 0x63, 0x5D, 0x6F, 0x3E,
    0x73, 0x3E, 0x6B, 0x1D, 0x73, 0x1E, 0x57, 0x7F, 0x5B, 0x7E, 0x53, 0x5D, 0x4F, 0x3C, 0x53, 0x3D,
    0x6F, 0x1D, 0x63, 0x1C, 0x4B, 0x5D, 0x47, 0x3C, 0x4B, 0x3D, 0x4F, 0x1C, 0x47, 0x1B, 0x43, 0x1B,
    0x57, 0x1C, 0x6B, 0xFC, 0x5F, 0xDB, 0x63, 0xBB, 0x67, 0xBB, 0x6B, 0x9B, 0x6F, 0x9A, 0x73, 0x9A,
    0x63, 0x9B, 0x5F, 0x7A, 0x5B, 0x7A, 0x6B, 0x5A, 0x67, 0x5A, 0x6B, 0x39, 0x67, 0x39, 0x5F, 0x1A,
    0x67, 0x19, 0x4F, 0x7A, 0x47, 0x7A, 0x53, 0x5A, 0x4B, 0x59, 0x57, 0x39, 0x4F, 0x39, 0x53, 0x19,
    0x4B, 0x18, 0x43, 0x19, 0x3F, 0x7A, 0x37, 0x79, 0x3F, 0x59, 0x3B, 0x59, 0x43, 0x38, 0x3F, 0x38,
    0x37, 0x58, 0x3F, 0x18, 0x3B, 0x17, 0x33, 0x58, 0x37, 0x38, 0x33, 0x37, 0x37, 0x17, 0x33, 0x17,
    0x2F, 0x58, 0x2B, 0x57, 0x2B, 0x37, 0x27, 0x36, 0x2F, 0x37, 0x2F, 0x17, 0x2B, 0x16, 0x27, 0x16,
    0x23, 0x36, 0x1F, 0x35, 0x23, 0x16, 0x1F, 0x15, 0x1B, 0x35, 0x1B, 0x15, 0x17, 0x15, 0x13, 0x14,
    0x53, 0xFA, 0x57, 0xDA, 0x4B, 0xFA, 0x43, 0xFA, 0x4B, 0xDA, 0x4F, 0xBB, 0x47, 0xDA, 0x4B, 0xBA,
    0x43, 0xBA, 0x47, 0x9A, 0x3B, 0xBA, 0x3F, 0x99, 0x37, 0xDA, 0x37, 0xBA, 0x33, 0x99, 0x37, 0x99,
    0x2B, 0xBA, 0x2F, 0x99, 0x27, 0xDA, 0x27, 0xBA, 0x23, 0x99, 0x27, 0x99, 0x1B, 0x99, 0x1F, 0x99,
    0x13, 0x99, 0x17, 0x78, 0x0F, 0x98, 0x17, 0x58, 0x0F, 0x58, 0x13, 0x58, 0x0B, 0x58, 0x0F, 0x37,
    0x63, 0xFD, 0x5B, 0xFD, 0x5F, 0xDD, 0x57, 0xDD, 0x53, 0xFD, 0x5B, 0xBD, 0x57, 0xBC, 0x4F, 0xBC,
    0x4F, 0x9C, 0x4B, 0x9C, 0x67, 0x7D, 0x5F, 0x7C, 0x5B, 0x7C, 0x53, 0x7C, 0x5F, 0x5C, 0x5B, 0x5B,
    0x67, 0x3C, 0x5F, 0x3B, 0x57, 0x3B, 0x53, 0x3B, 0x4F, 0x3A, 0x5B, 0x1B, 0x57, 0x1B, 0x4F, 0x1A,
    0x4B, 0x1A, 0x47, 0x7B, 0x4B, 0x5B, 0x43, 0x5A, 0x47, 0x3A, 0x43, 0x3A, 0x43, 0x1A, 0x3F, 0x19,
    0x3F, 0x7B, 0x37, 0x7B, 0x3B, 0x5A, 0x37, 0x5A, 0x3F, 0x39, 0x3B, 0x39, 0x37, 0x39, 0x3B, 0x19,
    0x37, 0x19, 0x33, 0x18, 0x2B, 0x5A, 0x2F, 0x59, 0x27, 0x59, 0x33, 0x39, 0x2F, 0x38, 0x2B, 0x38,
    0x27, 0x38, 0x2F, 0x18, 0x2B, 0x18, 0x27, 0x18, 0x23, 0x17, 0x1F, 0x59, 0x1F, 0x38, 0x1B, 0x37,
    0x1B, 0x17, 0x17, 0x17, 0x13, 0x37, 0x13, 0x17, 0x0F, 0x16, 0x0B, 0x16, 0x0B, 0x37, 0x07, 0x16,
    0x4F, 0xDB, 0x4B, 0x7C, 0x3B, 0x9B, 0x37, 0x9A, 0x31, 0x7E, 0x0D, 0x7F, 0x11, 0x5E, 0x09, 0x3D,
    0x11, 0x7F, 0x01, 0x3D, 0x2E, 0x96, 0x1E, 0x75, 0x0E, 0x54, 0x16, 0x33, 0x06, 0x13, 0x2B, 0x71,
    0x1A, 0x50, 0x0E, 0x51, 0x0A, 0x30, 0x02, 0x10, 0x72, 0xAD, 0x3A, 0xAA, 0x04, 0xAD, 0x43, 0x14,
    0x01, 0x08, 0x36, 0xB6, 0x1E, 0x95, 0x0E, 0x74, 0x06, 0x53, 0x02, 0x32, 0x00, 0x00, 0x00, 0x00,
    0x27, 0x0F, 0x1E, 0x0B, 0x1A, 0x0A, 0x16, 0x08, 0x12, 0x06, 0x16, 0x0A, 0x12, 0x09, 0x0E, 0x07,
    0x0E, 0x08, 0x0A, 0x06, 0x0E, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x67, 0x1F, 0x5A, 0x9B, 0x4A, 0x58, 0x3A, 0x36, 0x29, 0x14, 0x18, 0xB3, 0x46, 0xB4, 0x44, 0x20,
    0x03, 0xFF, 0x03, 0xDF, 0x03, 0x9D, 0x02, 0xFA, 0x03, 0x7B, 0x02, 0x57, 0x01, 0x74, 0x00, 0xD0
])
# Pad to 4096 to prevent indexing errors if palette logic is flawed
pal += bytes(4096 - len(pal))

render(r'e:\Dev\atolm\output\TITLEE.PNB', r'e:\Dev\atolm\output\TITLEE.SCB', pal, r'e:\Dev\atolm\output\titlee_perfect.png', bpp=8, is_12bit=True)

