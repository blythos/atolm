<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Panzer Dragoon Saga — Model Viewer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Instrument+Sans:wght@400;500;600;700&display=swap');

  :root {
    --bg: #0a0a0c;
    --panel: #111114;
    --panel-border: #1e1e24;
    --text: #c8c8d0;
    --text-dim: #6e6e7a;
    --text-bright: #e8e8f0;
    --accent: #4a9eff;
    --accent-dim: #2a5a9a;
    --accent-glow: rgba(74, 158, 255, 0.15);
    --warn: #ff9040;
    --success: #40c070;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Instrument Sans', sans-serif;
    overflow: hidden;
    height: 100vh;
  }

  #canvas-container {
    position: absolute;
    inset: 0;
    z-index: 0;
  }

  canvas { display: block; }

  /* ─── Top Bar ─── */
  #top-bar {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 48px;
    background: var(--panel);
    border-bottom: 1px solid var(--panel-border);
    display: flex;
    align-items: center;
    padding: 0 16px;
    z-index: 10;
    gap: 16px;
  }

  #top-bar .logo {
    font-family: 'JetBrains Mono', monospace;
    font-weight: 600;
    font-size: 13px;
    color: var(--accent);
    letter-spacing: 0.5px;
    white-space: nowrap;
  }

  #top-bar .logo span {
    color: var(--text-dim);
    font-weight: 300;
  }

  #top-bar .divider {
    width: 1px;
    height: 24px;
    background: var(--panel-border);
  }

  /* ─── File Selector ─── */
  #file-selector {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  #file-selector label {
    font-size: 11px;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: 500;
  }

  #file-select {
    background: var(--bg);
    color: var(--text-bright);
    border: 1px solid var(--panel-border);
    border-radius: 4px;
    padding: 4px 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    cursor: pointer;
    outline: none;
  }

  #file-select:hover { border-color: var(--accent-dim); }
  #file-select:focus { border-color: var(--accent); }

  /* ─── Hierarchy Selector ─── */
  #hier-select {
    background: var(--bg);
    color: var(--text-bright);
    border: 1px solid var(--panel-border);
    border-radius: 4px;
    padding: 4px 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    cursor: pointer;
    outline: none;
  }

  /* ─── Stats ─── */
  #stats-bar {
    margin-left: auto;
    display: flex;
    gap: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text-dim);
  }

  #stats-bar .stat-val { color: var(--text-bright); }

  /* ─── Side Panel ─── */
  #side-panel {
    position: absolute;
    top: 48px;
    right: 0;
    bottom: 0;
    width: 280px;
    background: var(--panel);
    border-left: 1px solid var(--panel-border);
    z-index: 10;
    overflow-y: auto;
    padding: 12px;
    transition: transform 0.2s ease;
  }

  #side-panel.collapsed { transform: translateX(280px); }

  #panel-toggle {
    position: absolute;
    top: 56px;
    right: 280px;
    z-index: 11;
    background: var(--panel);
    border: 1px solid var(--panel-border);
    border-right: none;
    border-radius: 4px 0 0 4px;
    color: var(--text-dim);
    padding: 8px 6px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    transition: right 0.2s ease;
  }

  #panel-toggle.collapsed { right: 0; }
  #panel-toggle:hover { color: var(--text-bright); }

  .panel-section {
    margin-bottom: 16px;
  }

  .panel-section h3 {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-dim);
    margin-bottom: 8px;
    font-weight: 600;
  }

  /* ─── Bone Tree ─── */
  .bone-tree {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    line-height: 1.8;
  }

  .bone-node {
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .bone-node:hover { background: rgba(255,255,255,0.04); }
  .bone-node.active { background: var(--accent-glow); color: var(--accent); }
  
  .bone-node .bone-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }
  
  .bone-node.active .bone-dot { background: var(--accent); }
  .bone-node.has-model .bone-dot { background: var(--success); }

  /* ─── Controls ─── */
  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
    font-size: 12px;
  }

  .control-row label {
    color: var(--text-dim);
    font-size: 11px;
  }

  .toggle {
    position: relative;
    width: 32px;
    height: 18px;
    background: var(--bg);
    border: 1px solid var(--panel-border);
    border-radius: 9px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .toggle.on { background: var(--accent-dim); border-color: var(--accent); }

  .toggle::after {
    content: '';
    position: absolute;
    top: 2px; left: 2px;
    width: 12px; height: 12px;
    background: var(--text-dim);
    border-radius: 50%;
    transition: transform 0.2s, background 0.2s;
  }

  .toggle.on::after { transform: translateX(14px); background: var(--accent); }

  /* ─── File Drop ─── */
  #drop-overlay {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 100;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 12px;
  }

  #drop-overlay.active { display: flex; }
  
  #drop-overlay .drop-icon {
    font-size: 48px;
    color: var(--accent);
    opacity: 0.6;
  }

  #drop-overlay p {
    color: var(--text-dim);
    font-size: 14px;
  }

  /* ─── Loading ─── */
  #loading {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(10,10,12,0.9);
    z-index: 50;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 8px;
  }

  #loading.active { display: flex; }

  #loading .spinner {
    width: 32px; height: 32px;
    border: 2px solid var(--panel-border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  #loading p { color: var(--text-dim); font-size: 13px; }

  /* ─── Welcome ─── */
  #welcome {
    position: absolute;
    inset: 0;
    z-index: 5;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 16px;
    pointer-events: none;
  }

  #welcome h2 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 16px;
    color: var(--text-dim);
    font-weight: 400;
  }

  #welcome p {
    color: var(--text-dim);
    font-size: 12px;
    opacity: 0.6;
  }

  /* ─── Scrollbar ─── */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--panel-border); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }
</style>
</head>
<body>

<div id="top-bar">
  <div class="logo">PDS<span>.VIEWER</span></div>
  <div class="divider"></div>
  <div id="file-selector">
    <label>Model</label>
    <select id="file-select"><option value="">— load JSON —</option></select>
    <select id="hier-select" style="display:none"><option value="">hierarchy</option></select>
  </div>
  <div id="stats-bar">
    <span>Quads: <span class="stat-val" id="stat-quads">0</span></span>
    <span>Verts: <span class="stat-val" id="stat-verts">0</span></span>
    <span>Bones: <span class="stat-val" id="stat-bones">0</span></span>
    <span>Textures: <span class="stat-val" id="stat-textures">0</span></span>
  </div>
</div>

<button id="panel-toggle">◀</button>

<div id="side-panel">
  <div class="panel-section">
    <h3>Display</h3>
    <div class="control-row">
      <label>Wireframe</label>
      <div class="toggle" id="toggle-wireframe" onclick="toggleControl(this, 'wireframe')"></div>
    </div>
    <div class="control-row">
      <label>Textures</label>
      <div class="toggle on" id="toggle-textures" onclick="toggleControl(this, 'textures')"></div>
    </div>
    <div class="control-row">
      <label>Bones</label>
      <div class="toggle" id="toggle-bones" onclick="toggleControl(this, 'showBones')"></div>
    </div>
    <div class="control-row">
      <label>Backfaces</label>
      <div class="toggle" id="toggle-backface" onclick="toggleControl(this, 'backfaces')"></div>
    </div>
    <div class="control-row">
      <label>Grid</label>
      <div class="toggle on" id="toggle-grid" onclick="toggleControl(this, 'grid')"></div>
    </div>
  </div>

  <div class="panel-section">
    <h3>Bone Hierarchy</h3>
    <div id="bone-tree" class="bone-tree"></div>
  </div>
</div>

<div id="canvas-container"></div>

<div id="loading"><div class="spinner"></div><p id="loading-text">Loading...</p></div>

<div id="welcome">
  <h2>Drop a .json model file or select from the list</h2>
  <p>Extracted with pds_extract.py — quad topology preserved</p>
</div>

<div id="drop-overlay">
  <div class="drop-icon">⬇</div>
  <p>Drop .json model file</p>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── State ───
const state = {
  wireframe: false,
  textures: true,
  showBones: false,
  backfaces: false,
  grid: true,
  currentData: null,
  currentHierarchy: 0,
  modelGroup: null,
  boneHelpers: null,
  textureCache: {},
};

// ─── Three.js Setup ───
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0c);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404050, 0.8);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(3, 5, 4);
scene.add(dirLight);

const fillLight = new THREE.DirectionalLight(0x4060a0, 0.4);
fillLight.position.set(-3, 1, -2);
scene.add(fillLight);

// Grid
const gridHelper = new THREE.GridHelper(20, 40, 0x1a1a22, 0x12121a);
scene.add(gridHelper);

// Axes
const axesHelper = new THREE.AxesHelper(0.5);
scene.add(axesHelper);

// ─── Orbit Controls (manual implementation) ───
let orbiting = false, panning = false;
let orbitTheta = 0, orbitPhi = Math.PI / 6;
let orbitRadius = 5;
let orbitTarget = new THREE.Vector3(0, 0.5, 0);
let mouseStart = { x: 0, y: 0 };

function updateCamera() {
  const x = orbitTarget.x + orbitRadius * Math.sin(orbitTheta) * Math.cos(orbitPhi);
  const y = orbitTarget.y + orbitRadius * Math.sin(orbitPhi);
  const z = orbitTarget.z + orbitRadius * Math.cos(orbitTheta) * Math.cos(orbitPhi);
  camera.position.set(x, y, z);
  camera.lookAt(orbitTarget);
}

renderer.domElement.addEventListener('mousedown', (e) => {
  if (e.button === 0) orbiting = true;
  if (e.button === 2 || e.button === 1) panning = true;
  mouseStart = { x: e.clientX, y: e.clientY };
  e.preventDefault();
});

window.addEventListener('mouseup', () => { orbiting = false; panning = false; });
window.addEventListener('contextmenu', (e) => e.preventDefault());

window.addEventListener('mousemove', (e) => {
  const dx = e.clientX - mouseStart.x;
  const dy = e.clientY - mouseStart.y;
  mouseStart = { x: e.clientX, y: e.clientY };

  if (orbiting) {
    orbitTheta -= dx * 0.005;
    orbitPhi = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, orbitPhi + dy * 0.005));
    updateCamera();
  }
  if (panning) {
    const panSpeed = orbitRadius * 0.002;
    const right = new THREE.Vector3();
    const up = new THREE.Vector3();
    camera.getWorldDirection(up);
    right.crossVectors(up, camera.up).normalize();
    up.copy(camera.up).normalize();
    orbitTarget.add(right.multiplyScalar(-dx * panSpeed));
    orbitTarget.add(up.multiplyScalar(dy * panSpeed));
    updateCamera();
  }
});

renderer.domElement.addEventListener('wheel', (e) => {
  orbitRadius *= (1 + e.deltaY * 0.001);
  orbitRadius = Math.max(0.1, Math.min(100, orbitRadius));
  updateCamera();
  e.preventDefault();
}, { passive: false });

updateCamera();

// ─── Texture Loading ───
function loadTexture(texData) {
  const key = texData.dataUrl.substring(0, 60); // Use prefix as cache key
  if (state.textureCache[key]) return state.textureCache[key];

  const tex = new THREE.TextureLoader().load(texData.dataUrl);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  tex.wrapS = THREE.ClampToEdgeWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.flipY = false; // Saturn textures are top-down
  state.textureCache[key] = tex;
  return tex;
}

// ─── Quad Mesh Builder ───
// Renders quads as two triangles (0,1,2) and (0,2,3) with proper UV mapping
// This preserves the quad topology in the data while rendering correctly

function buildModelMesh(model, textures, parentMatrix) {
  const group = new THREE.Group();
  if (parentMatrix) group.applyMatrix4(parentMatrix);

  const verts = model.vertices;

  // Group quads by texture for batching
  const quadsByTex = {};
  for (const quad of model.quads) {
    const key = quad.textureKey || '__notex__';
    if (!quadsByTex[key]) quadsByTex[key] = [];
    quadsByTex[key].push(quad);
  }

  for (const [texKey, quads] of Object.entries(quadsByTex)) {
    const positions = [];
    const uvs = [];
    const indices = [];

    for (const quad of quads) {
      const [a, b, c, d] = quad.indices;
      const baseIdx = positions.length / 3;

      // Add 4 vertices for this quad
      for (const vi of [a, b, c, d]) {
        const v = verts[vi];
        // Convert to viewer coords: Saturn Y-up, negate Z for right-hand
        positions.push(v[0], v[1], -v[2]);
      }

      // UV mapping for quad: maps texture to four corners
      // VDP1 maps texture: A=top-left, B=top-right, C=bottom-right, D=bottom-left
      let u0 = 0, v0 = 0, u1 = 1, v1 = 1;

      // Apply texture flip
      if (quad.flipH) { const tmp = u0; u0 = u1; u1 = tmp; }
      if (quad.flipV) { const tmp = v0; v0 = v1; v1 = tmp; }

      uvs.push(u0, v0);  // A: top-left
      uvs.push(u1, v0);  // B: top-right
      uvs.push(u1, v1);  // C: bottom-right
      uvs.push(u0, v1);  // D: bottom-left

      // Two triangles: ABC and ACD
      indices.push(baseIdx, baseIdx + 1, baseIdx + 2);
      indices.push(baseIdx, baseIdx + 2, baseIdx + 3);
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    let material;
    const texData = textures[texKey];

    if (state.textures && texData && texData.dataUrl) {
      const tex = loadTexture(texData);
      material = new THREE.MeshPhongMaterial({
        map: tex,
        side: state.backfaces ? THREE.DoubleSide : THREE.FrontSide,
        transparent: true,
        alphaTest: 0.1,
        wireframe: state.wireframe,
      });
    } else {
      material = new THREE.MeshPhongMaterial({
        color: 0x808090,
        side: state.backfaces ? THREE.DoubleSide : THREE.FrontSide,
        wireframe: state.wireframe,
      });
    }

    const mesh = new THREE.Mesh(geometry, material);
    group.add(mesh);
  }

  return group;
}

// ─── Hierarchy Builder ───
// Walks the bone tree, applying transforms from pose data

function buildHierarchy(data, hierIndex) {
  const hier = data.hierarchies[hierIndex];
  if (!hier) return new THREE.Group();

  const pose = data.poses[hierIndex] || null;
  const nodes = hier.nodes;
  const textures = data.textures;

  // Build offset -> node mapping
  const nodeByOffset = {};
  for (const node of nodes) {
    nodeByOffset[node.offset] = node;
  }

  // Build offset -> model mapping
  const offsetToModelKey = {};
  for (const [key, model] of Object.entries(data.models)) {
    const ptrEntry = data.pointerTable[parseInt(key)];
    if (ptrEntry) {
      offsetToModelKey[ptrEntry.offset] = key;
    }
  }

  const group = new THREE.Group();
  const bonePositions = []; // For bone visualization

  let boneIndex = 0;

  function walkNode(offset, parentGroup) {
    const node = nodeByOffset[offset];
    if (!node) return;

    const boneGroup = new THREE.Group();
    boneGroup.name = `bone_${boneIndex}`;

    // Apply pose transform if available
    if (pose && boneIndex < pose.bones.length) {
      const bone = pose.bones[boneIndex];
      
      // Translation (already in world units from 16.16 fixed point)
      boneGroup.position.set(
        bone.translation[0],
        bone.translation[1],
        -bone.translation[2] // Negate Z for right-hand coords
      );

      // Rotation: Saturn uses ZYX order, angles in degrees (converted from 16.16 where 1.0 = 360°)
      const toRad = Math.PI / 180;
      const rx = bone.rotation[0] * toRad;
      const ry = bone.rotation[1] * toRad;
      const rz = bone.rotation[2] * toRad;

      // Apply ZYX rotation order (Saturn convention)
      const euler = new THREE.Euler(rx, -ry, -rz, 'ZYX');
      boneGroup.rotation.copy(euler);

      // Scale
      boneGroup.scale.set(bone.scale[0], bone.scale[1], bone.scale[2]);
    }

    boneIndex++;

    // Get world position for bone visualization
    const worldPos = new THREE.Vector3();
    parentGroup.updateWorldMatrix(true, false);
    boneGroup.updateWorldMatrix(true, false);

    // Add model if this bone has one
    if (node.modelOffset !== 0) {
      const modelKey = offsetToModelKey[node.modelOffset];
      if (modelKey && data.models[modelKey]) {
        const modelMesh = buildModelMesh(data.models[modelKey], textures);
        boneGroup.add(modelMesh);
      }
    }

    parentGroup.add(boneGroup);

    // Record bone position for helper
    bonePositions.push({
      group: boneGroup,
      hasModel: node.modelOffset !== 0,
    });

    // Walk children
    if (node.childOffset !== 0) {
      walkNode(node.childOffset, boneGroup);
    }

    // Walk siblings
    if (node.siblingOffset !== 0) {
      walkNode(node.siblingOffset, parentGroup);
    }
  }

  // Start walk from the first node (root)
  if (nodes.length > 0) {
    walkNode(nodes[0].offset, group);
  }

  // Store bone positions for helper visualization
  group.userData.bonePositions = bonePositions;

  return group;
}

// ─── Bone Helper Visualization ───
function buildBoneHelpers(modelGroup) {
  const helpers = new THREE.Group();
  const bonePositions = modelGroup.userData.bonePositions;
  if (!bonePositions) return helpers;

  for (const bp of bonePositions) {
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshBasicMaterial({
        color: bp.hasModel ? 0x40c070 : 0xff9040,
        depthTest: false,
      })
    );
    sphere.renderOrder = 999;

    // Get world position
    bp.group.updateWorldMatrix(true, false);
    const worldPos = new THREE.Vector3();
    worldPos.setFromMatrixPosition(bp.group.matrixWorld);
    sphere.position.copy(worldPos);

    helpers.add(sphere);
  }

  return helpers;
}

// ─── Build Flat View (all models at origin, no hierarchy) ───
function buildFlatView(data) {
  const group = new THREE.Group();
  for (const [key, model] of Object.entries(data.models)) {
    const mesh = buildModelMesh(model, data.textures);
    group.add(mesh);
  }
  return group;
}

// ─── Load Model Data ───
function loadModelData(data) {
  state.currentData = data;
  state.textureCache = {};

  document.getElementById('welcome').style.display = 'none';

  // Update hierarchy selector
  const hierSelect = document.getElementById('hier-select');
  hierSelect.innerHTML = '';

  if (data.hierarchies.length > 0) {
    for (let i = 0; i < data.hierarchies.length; i++) {
      const h = data.hierarchies[i];
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `Hierarchy ${i} (${h.boneCount} bones)`;
      hierSelect.appendChild(opt);
    }
    // Add "All models (flat)" option
    const flatOpt = document.createElement('option');
    flatOpt.value = 'flat';
    flatOpt.textContent = 'All models (flat)';
    hierSelect.appendChild(flatOpt);

    hierSelect.style.display = '';
    hierSelect.value = '0';
  } else {
    hierSelect.style.display = 'none';
  }

  state.currentHierarchy = 0;
  rebuildScene();

  // Update stats
  document.getElementById('stat-quads').textContent = data.stats.totalQuads;
  document.getElementById('stat-verts').textContent = data.stats.totalVertices;
  document.getElementById('stat-bones').textContent = data.hierarchies.length > 0 ? data.hierarchies[0].boneCount : 0;
  document.getElementById('stat-textures').textContent = data.stats.textureCount;

  // Auto-frame
  autoFrame();
}

function rebuildScene() {
  // Remove old model
  if (state.modelGroup) {
    scene.remove(state.modelGroup);
    state.modelGroup = null;
  }
  if (state.boneHelpers) {
    scene.remove(state.boneHelpers);
    state.boneHelpers = null;
  }

  const data = state.currentData;
  if (!data) return;

  const hierVal = document.getElementById('hier-select').value;

  if (hierVal === 'flat' || data.hierarchies.length === 0) {
    state.modelGroup = buildFlatView(data);
  } else {
    const hierIdx = parseInt(hierVal);
    state.modelGroup = buildHierarchy(data, hierIdx);
  }

  // Scale: divide by 4096 for reasonable viewer scale (16.16 fixed point to world)
  // Actually vertices are already divided by 16 (12.4), and bone translations by 65536 (16.16)
  // Let's just normalize to fit
  scene.add(state.modelGroup);

  // Build bone helpers
  if (state.showBones) {
    state.boneHelpers = buildBoneHelpers(state.modelGroup);
    scene.add(state.boneHelpers);
  }

  // Build bone tree UI
  buildBoneTreeUI(data, hierVal);

  // Update grid visibility
  gridHelper.visible = state.grid;
}

function autoFrame() {
  if (!state.modelGroup) return;

  const box = new THREE.Box3().setFromObject(state.modelGroup);
  if (box.isEmpty()) return;

  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);

  orbitTarget.copy(center);
  orbitRadius = maxDim * 2.5;
  orbitPhi = Math.PI / 8;
  orbitTheta = Math.PI / 6;
  updateCamera();
}

// ─── Bone Tree UI ───
function buildBoneTreeUI(data, hierVal) {
  const treeEl = document.getElementById('bone-tree');
  treeEl.innerHTML = '';

  if (hierVal === 'flat' || data.hierarchies.length === 0) {
    treeEl.innerHTML = '<span style="color:var(--text-dim);font-size:11px">No hierarchy selected</span>';
    return;
  }

  const hierIdx = parseInt(hierVal);
  const hier = data.hierarchies[hierIdx];
  if (!hier) return;

  for (let i = 0; i < hier.nodes.length; i++) {
    const node = hier.nodes[i];
    const el = document.createElement('div');
    el.className = 'bone-node' + (node.modelOffset !== 0 ? ' has-model' : '');
    el.style.paddingLeft = (8 + node.depth * 12) + 'px';
    el.innerHTML = `<span class="bone-dot"></span>Bone ${i}`;
    el.title = `offset: 0x${node.offset.toString(16).toUpperCase()}\nmodel: 0x${node.modelOffset.toString(16).toUpperCase()}`;
    treeEl.appendChild(el);
  }
}

// ─── Controls ───
function toggleControl(el, key) {
  state[key] = !state[key];
  el.classList.toggle('on', state[key]);

  if (key === 'wireframe' || key === 'textures' || key === 'backfaces') {
    rebuildScene();
  }
  if (key === 'showBones') {
    if (state.boneHelpers) {
      scene.remove(state.boneHelpers);
      state.boneHelpers = null;
    }
    if (state.showBones && state.modelGroup) {
      state.boneHelpers = buildBoneHelpers(state.modelGroup);
      scene.add(state.boneHelpers);
    }
  }
  if (key === 'grid') {
    gridHelper.visible = state.grid;
  }
}

// ─── Panel Toggle ───
document.getElementById('panel-toggle').addEventListener('click', function() {
  document.getElementById('side-panel').classList.toggle('collapsed');
  this.classList.toggle('collapsed');
  this.textContent = this.classList.contains('collapsed') ? '▶' : '◀';
  // Resize renderer
  setTimeout(() => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  }, 250);
});

// ─── Hierarchy Selector ───
document.getElementById('hier-select').addEventListener('change', function() {
  rebuildScene();
  
  const val = this.value;
  if (val !== 'flat' && state.currentData) {
    const hier = state.currentData.hierarchies[parseInt(val)];
    if (hier) {
      document.getElementById('stat-bones').textContent = hier.boneCount;
    }
  }
  
  autoFrame();
});

// ─── File Drag & Drop ───
document.addEventListener('dragover', (e) => {
  e.preventDefault();
  document.getElementById('drop-overlay').classList.add('active');
});

document.getElementById('drop-overlay').addEventListener('dragleave', () => {
  document.getElementById('drop-overlay').classList.remove('active');
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  document.getElementById('drop-overlay').classList.remove('active');

  const file = e.dataTransfer.files[0];
  if (!file || !file.name.endsWith('.json')) return;

  showLoading('Loading ' + file.name + '...');
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      loadModelData(data);
    } catch (err) {
      console.error('Failed to parse JSON:', err);
    }
    hideLoading();
  };
  reader.readAsText(file);
});

// ─── Loading UI ───
function showLoading(text) {
  document.getElementById('loading-text').textContent = text || 'Loading...';
  document.getElementById('loading').classList.add('active');
}

function hideLoading() {
  document.getElementById('loading').classList.remove('active');
}

// ─── Window Resize ───
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ─── Animation Loop ───
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();


// ─── File Loading ───
// Models loaded from JSON files in the same directory via manifest.json.
// Also supports drag-and-drop of individual .json files.

const _modelCache = {};  // Runtime cache for fetched model data

function populateFileList(manifest) {
  const select = document.getElementById('file-select');
  select.innerHTML = '<option value="">— select model —</option>';
  
  for (const file of manifest.files) {
    const opt = document.createElement('option');
    opt.value = file.name;
    opt.textContent = `${file.name} (${file.stats.totalQuads}q ${file.stats.modelCount}m)`;
    select.appendChild(opt);
  }
}

document.getElementById('file-select').addEventListener('change', async function() {
  const name = this.value;
  if (!name) return;

  if (_modelCache[name]) {
    loadModelData(_modelCache[name]);
    return;
  }

  // Try loading from relative path
  showLoading('Loading ' + name + '...');
  try {
    const resp = await fetch(name + '.json');
    if (resp.ok) {
      const data = await resp.json();
      _modelCache[name] = data;
      loadModelData(data);
    }
  } catch (e) {
    console.warn('Could not fetch', name);
  }
  hideLoading();
});

// ─── Auto-load manifest.json from same directory ───
async function autoLoadManifest() {
  try {
    const resp = await fetch('manifest.json');
    if (!resp.ok) return;
    const manifest = await resp.json();
    populateFileList(manifest);
    document.getElementById('welcome').querySelector('h2').textContent = 
      manifest.totalFiles + ' models available — select from the dropdown';
    // Auto-select first model
    if (manifest.files.length > 0) {
      const first = manifest.files[0].name;
      document.getElementById('file-select').value = first;
      document.getElementById('file-select').dispatchEvent(new Event('change'));
    }
  } catch (e) {
    // No manifest found — user can drag-and-drop JSON files
  }
}

// ─── Animation Playback State ───
let animPlaying = false;
let animFrame = 0;
let animIndex = 0;
let animFrameTimer = 0;
const ANIM_FPS = 15; // Saturn runs at ~30fps, but keyframes are sparser

function updateAnimationUI(data) {
  const container = document.getElementById('stats-bar');
  // Add animation selector if not present
  let animSel = document.getElementById('anim-select');
  if (!animSel) {
    animSel = document.createElement('select');
    animSel.id = 'anim-select';
    animSel.style.cssText = 'background:var(--bg);color:var(--text-bright);border:1px solid var(--panel-border);border-radius:4px;padding:2px 6px;font-family:JetBrains Mono,monospace;font-size:11px;cursor:pointer;margin-left:8px;';
    document.getElementById('file-selector').appendChild(animSel);
    
    const playBtn = document.createElement('button');
    playBtn.id = 'play-btn';
    playBtn.textContent = '▶';
    playBtn.style.cssText = 'background:var(--bg);color:var(--accent);border:1px solid var(--panel-border);border-radius:4px;padding:2px 8px;cursor:pointer;font-size:12px;margin-left:4px;';
    playBtn.onclick = togglePlay;
    document.getElementById('file-selector').appendChild(playBtn);
  }
  
  animSel.innerHTML = '<option value="-1">Rest Pose</option>';
  if (data.animations) {
    data.animations.forEach((a, i) => {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = 'Anim ' + i + ' (' + a.numBakedFrames + 'f, mode' + a.mode + ')';
      animSel.appendChild(opt);
    });
    if (data.animations.length > 0) {
      animSel.value = '0';
      animIndex = 0;
      applyAnimationFrame(0);
    }
  }
  animSel.onchange = function() {
    animIndex = parseInt(this.value);
    animFrame = 0;
    if (animIndex >= 0) applyAnimationFrame(0);
    else rebuildScene();
  };
}

function togglePlay() {
  animPlaying = !animPlaying;
  document.getElementById('play-btn').textContent = animPlaying ? '⏸' : '▶';
}

function applyAnimationFrame(frame) {
  const data = state.currentData;
  if (!data || animIndex < 0 || animIndex >= data.animations.length) return;
  const anim = data.animations[animIndex];
  if (frame >= anim.frames.length) frame = 0;
  
  // Apply animation frame as the pose, then rebuild
  const hierVal = document.getElementById('hier-select').value;
  if (hierVal === 'flat' || data.hierarchies.length === 0) return;
  
  // Store current animation frame data for the rebuild
  state.currentAnimFrame = anim.frames[frame];
  rebuildScene();
}

// ─── Override buildHierarchy to use animation frame data ───
const _origBuildHierarchy = buildHierarchy;
buildHierarchy = function(data, hierIndex) {
  const hier = data.hierarchies[hierIndex];
  if (!hier) return new THREE.Group();
  
  // Use animation frame if available, otherwise pose data
  const animFrame = state.currentAnimFrame;
  const pose = data.poses[hierIndex] || null;
  const nodes = hier.nodes;
  const textures = data.textures;
  
  const nodeByOffset = {};
  for (const node of nodes) nodeByOffset[node.offset] = node;
  
  const offsetToModelKey = {};
  for (const [key, model] of Object.entries(data.models)) {
    const ptrEntry = data.pointerTable[parseInt(key)];
    if (ptrEntry) offsetToModelKey[ptrEntry.offset] = key;
  }
  
  const group = new THREE.Group();
  const bonePositions = [];
  let boneIndex = 0;
  
  function walkNode(offset, parentGroup) {
    const node = nodeByOffset[offset];
    if (!node) return;
    
    const boneGroup = new THREE.Group();
    boneGroup.name = 'bone_' + boneIndex;
    
    // Get transform from animation frame or pose
    let tx=0, ty=0, tz=0, rx=0, ry=0, rz=0;
    
    if (animFrame && boneIndex < animFrame.length) {
      const af = animFrame[boneIndex];
      tx = af.translation[0]; ty = af.translation[1]; tz = af.translation[2];
      rx = af.rotation[0]; ry = af.rotation[1]; rz = af.rotation[2];
    } else if (pose && boneIndex < pose.bones.length) {
      const b = pose.bones[boneIndex];
      tx = b.translation[0]; ty = b.translation[1]; tz = b.translation[2];
      rx = b.rotation[0]; ry = b.rotation[1]; rz = b.rotation[2];
    }
    
    boneGroup.position.set(tx, ty, -tz);
    
    const toRad = Math.PI / 180;
    // Saturn rotation order: ZYX, applied as rotateZ then rotateY then rotateX
    // The hierarchy drawing code does: rotateCurrentMatrixZYX
    // which calls rotateZ(-rz), rotateX(-rx), rotateY(-ry)
    // Note the NEGATION in the yaz0r code
    boneGroup.rotation.order = 'YXZ';  // Three.js applies in reverse order
    boneGroup.rotation.set(-rx * toRad, -ry * toRad, -rz * toRad);
    
    boneIndex++;
    
    if (node.modelOffset !== 0) {
      const modelKey = offsetToModelKey[node.modelOffset];
      if (modelKey && data.models[modelKey]) {
        const modelMesh = buildModelMesh(data.models[modelKey], textures);
        boneGroup.add(modelMesh);
      }
    }
    
    parentGroup.add(boneGroup);
    bonePositions.push({ group: boneGroup, hasModel: node.modelOffset !== 0 });
    
    if (node.childOffset !== 0) walkNode(node.childOffset, boneGroup);
    if (node.siblingOffset !== 0) walkNode(node.siblingOffset, parentGroup);
  }
  
  if (nodes.length > 0) walkNode(nodes[0].offset, group);
  group.userData.bonePositions = bonePositions;
  return group;
};

// Override loadModelData to setup animation UI
const _origLoadModelData = loadModelData;
loadModelData = function(data) {
  state.currentAnimFrame = null;
  _origLoadModelData(data);
  updateAnimationUI(data);
};

// Animation loop update
const _origAnimate = animate;
let lastAnimTime = 0;
function animateWithPlayback() {
  requestAnimationFrame(animateWithPlayback);
  renderer.render(scene, camera);
  
  if (animPlaying && state.currentData && animIndex >= 0) {
    const now = performance.now();
    if (now - lastAnimTime > 1000 / ANIM_FPS) {
      lastAnimTime = now;
      const anim = state.currentData.animations[animIndex];
      if (anim) {
        animFrame = (animFrame + 1) % anim.frames.length;
        applyAnimationFrame(animFrame);
      }
    }
  }
}

// Replace animation loop
animateWithPlayback();

// Start
autoLoadManifest();

</script>
</body>
</html>
